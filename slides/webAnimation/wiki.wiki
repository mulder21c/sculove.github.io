http://cwdoh.com/html5/2014/08/18/chrome-enchanted-notable-html5-specs-in-2014/
https://developers.google.com/web/fundamentals/look-and-feel/animations/css-vs-javascript
http://beautifulcss.com/archives/2026
https://developers.google.com/web/updates/2014/12/web-animation-playback?hl=en
http://www.tiki-toki.com/timeline/entry/212780/history-of-animation/#vars!date=2010-01-20_14:40:22!
https://www.polymer-project.org/0.5/platform/web-animations.html
http://danielcwilson.com/blog/2015/09/animations-part-4/
https://developer.mozilla.org/ko/docs/Web/CSS/Using_CSS_animations


interface AnimationEffectTiming : AnimationEffectTimingReadOnly {
    inherit attribute double                             delay;
    inherit attribute double                             endDelay;
    inherit attribute FillMode                           fill;
    inherit attribute double                             iterationStart;
    inherit attribute unrestricted double                iterations;
    inherit attribute (unrestricted double or DOMString) duration;
    inherit attribute PlaybackDirection                  direction;
    inherit attribute DOMString                          easing;
};

                    AnimationPlayer
                    Element.animate(an array of KeyframeEffects, AnimationEffectTimingProperties options);

                    @CSS Animation @keyframe
                    animation-property

                    // Timelines
                    AnimationPlayer.playState
                    AnimationPlayer.playBackRate (read/write)
                    AnimationPlayer.currentTime (read/write)
                    AnimationPlayer.finish()
                    AnimationPlayer.play()
                    AnimationPlayer.reverse()   // currentTime ==> 0이 마지막

                    AnimationEvent
                    AnimationPlayer.onfinish
                    AnimationPlayer.oncancel

                    // Multiple (FF Nightly만 지원)
                    //Get all the AnimationPlayers
                    var players = document.timeline.getAnimations();

                    // group and sequence animations
                    KeyframeEffect 단일 (크롬 안됨)
                    GroupEffect 그룹 (크롬 안됨)
                    var groupEffectA = new GroupEffect(keyframeEffects);
                    var anim = document.timeline.play(groupEffectA);
                    SequenceEffect (크롬 안됨)
                    var sequence = new SequenceEffect(kEffects);
                    document.timeline.play(sequence);


                    Animation (크롬 안됨)


                    Motion Path



                    애니메이션 컨트롤 AnimationPlayer, Timeline
                    Multiple
                    GroupEffects, SequenceEffects
                    * 애니메이션의 순차적, 그리고 동시적인 수행의 조합
                    * 애니메이션의 재생 방법(시작위치, 반복, 재생방향 등) 설정과 재생
                    * SVG 패스를 따라 이동하는 애니메이션 구현


h1. Web Animations API

{toc:minLevel=2}

h2. 개요

최근 W3C 에서는 CSS Transition 보다 더욱 인터랙티브한 애니메이션 동작을 구현 할 수 있도록 도와주는 스펙이 Web Animations API 라는 이름으로 Working Draft 상태로 논의 되고 있다.

아래 문서에서 논의중인 내용과 API 의 인터페이스를 확인 할 수 있으며,
http://www.w3.org/TR/web-animations/

아래 URL 에서 문서에서 정의하고 있는 인터페이스에 맞추어  사용 할 수 있도록 개발한 Polyfill 라이브러리 코드를 다운로드 받을 수 있다.
https://github.com/web-animations/web-animations-js

h2. 주요기능

* 애니메이션의 순차적, 그리고 동시적인 수행의 조합
* 애니메이션의 재생 방법(시작위치, 반복, 재생방향 등) 설정과 재생
* SVG 패스를 따라 이동하는 애니메이션 구현

h2. 주요 클래스 및 인터페이스

h3. Animation 클래스

h4. 설명
단일 애니메이션 효과 객체를 생성한다.

h4. 사용방법

가장 간단한 객체 생성방법이다.

{code}
// new Animation(대상엘리먼트, 종료속성객체, 시간);
var anim = new Animation(target, {'left':'200px'}, 3);
// target 의 left 스타일을 현재 값으로부터 200px 까지 3초동안 변화시키는 객체 생성
{code}

두번째 인자를 바꿔줌으로써 아래와 같이 시작속성을 지정 할 수도 있다.

{code}
// new Animation(대상엘리먼트, [ 시작속성객체, 종료속성객체 ], 시간);
var anim = new Animation(target, [ {'left':'100px'}, {'left':'200px'} ], 3);
// target 의 left 스타일을 100px 에서 200px 까지 3초동안 변화시키는 객체 생성
{code}

중간속성을 여러 개 지정하는 것도 가능하다.

{code}
// new Animation(대상엘리먼트, [ 시작속성객체, 중간속성객체1, 중간속성객체2, 종료속성객체 ], 시간);
var anim = new Animation(target, [
    {'left':'100px'},
    {'left':'300px'},
    {'left':'50px'},
    {'left':'200px'}
], 3);
// target 의 left 스타일을 100px 부터 시작해서 300px, 50px 을 거쳐 200px 까지 3초동안 변화시키는 객체 생성
{code}

SVG 의 Path 를 따라 움직이게 할 수도 있다.

{code}
// new Animation(대상엘리먼트, Path애니메이션효과, 시간);

var func = new PathAnimationEffect(document.getElementById('path').pathSegList);
var anim = new Animation(target , func, 2);
// target 을 SVG Path 을 따라 2초동안 변화시키는 객체 생성
{code}

사용자가 직접 만든 애니메이션 효과를 사용 할 수도 있다.

{code}
// new Animation(대상엘리먼트, Path애니메이션효과, 시간);

var func = new CustomAnimationEffect(...);
var anim = new Animation(target , func, 2);
// target 을 SVG Path 을 따라 2초동안 변화시키는 객체 생성
{code}

지금까지는 세번째 인자로 숫자를 넣어 몇 초동안 움직일지 지정 했지만 TimingInput 인터페이스의 객체를 넣어 다양한 형태로 동작 시킬 수 있다.

{code}
// new Animation(대상엘리먼트, [ 시작속성객체, 종료속성객체 ], TimingInput객체);
var anim = new Animation(target, [ {'left':'100px'}, {'left':'200px'} ], {
    duration : 3,
    iterationStart : 0,
    iterations : 1,
    delay : 1,
    fill : 'backwards',
    playbackRate : 1,
    direction : 'normal',
    easing : 'linear'
});
// target 의 left 스타일을 100px 에서 200px 까지 옵션에 맞게 변화시키는 객체 생성
{code}

h3. TimingInput 인터페이스

TimingInput 인터페이스는 애니메이션을 어떤 효과로 움직이게 할지에 대해 정의하여 다음과 같은 프로퍼티를 가진다.

h4. duration : 애니메이션 시간

몇 초동안 움직이게 할지 지정 할 수 있으며 단위는 '초', 기본값은 0 이다.

h4. iterations : 진행 이터레이션 크기

시작값부터 종료값까지 한번 변화하는 것을 1번의 이터레이션이 진행되었다고 하며, 이 옵션을 통해 이터레이션의 크기를 정할 수 있다.

{code}
{ iterations : 2, duration : 3 } // 3초의 애니메이션이 두번 반복
{code}

{code}
{ iterations : 2.5 } // 애니메이션이 두번 반복되고 남은 한번은 절반만 진행
{code}

h4. iterationStart : 시작 이터레이션 위치

이터레이션 시작 위치를 지정 할 수 있으며 시작지점을 0, 종료지점을 1 로 환산하여 0.0 부터 1.0 사이의 숫자를 지정 해 줄 수 있다.
기본값은 0.0 이다.

{code}
// 0px 부터 100px 까지 1초 동안 진행되는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    duration : 1,
    iterationStart : 0.0,
    iterations : 1.0
});

// 0px 부터 80px 까지 0.8초 동안 진행되는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    duration : 1,
    iterationStart : 0.0,
    iterations : 0.8
});

// 20px 부터 100px 까지 0.8초 동안 진행되는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    duration : 1,
    iterationStart : 0.2,
    iterations : 0.8
});

// 20px 부터 80px 까지 0.6초 동안 진행되는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    iterationStart : 0.2,
    iterations : 0.6
});

// 50px 부터 100px 까지 진행되고, 0px 부터 100px 까지 진행되고, 0px 부터 50px 까지 2초 동안 진행되는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    iterationStart : 0.5,
    iterations : 2
});
{code}

h4. delay : 시작 전 딜레이

애니메이션이 시작되기 전의 딜레이 시간을 '초' 단위로 지정 할 수 있다. 기본값은 0 이다.

{code}
// 3초후에 0px 부터 100px 까지 2초동안 진행되는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    delay : 3,
    duration : 2
});
{code}

h4. fill : 변화의 연장

변화를 어느 방향으로 연장 시킬 지 정의한다. 변화를 앞 부분(forwards)로 연장시키면 delay 로 인해 기다리고 있는 중에 지정 한 시작값을 유지하며, 변화를 뒷 부분(backwards)로 연장시키면 애니메이션이 끝난 후에도 종료값을 유지한다. 사용가능한 값은 아래 4가지 이며 기본값은 forwards 이다.

* none : 연장 안함
* backwards : 앞 부분으로 연장함
* forwards : 뒷 부분으로 연장함
* both : 양쪽 방향 모두 연장함

{code}
// 애니메이션을 시작하면 가만히 있다가 3초후에 0px 부터 100px 까지 2초동안 진행되고,
// 애니메이션이 끝나면 다시 시작 전 위치로 돌아오는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    delay : 3,
    duration : 2,
    fill : 'none'
});
{code}

{code}
// 애니메이션을 시작하면 100px 로 이동했다가 3초후에 0px 부터 100px 까지 2초동안 진행되고,
// 애니메이션이 끝나면 다시 시작 전 위치로 돌아오는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    delay : 3,
    duration : 2,
    fill : 'backwards'
});
{code}

{code}
// 애니메이션을 시작하면 가만히 있다가 3초후에 0px 부터 100px 까지 2초동안 진행되고,
// 애니메이션이 끝나도 마지막 위치인 100px 을 유지하는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    delay : 3,
    duration : 2,
    fill : 'forwards'
});
{code}

{code}
// 애니메이션을 시작하면 100px 로 이동했다가 3초후에 0px 부터 100px 까지 2초동안 진행되고,
// 애니메이션이 끝나도 마지막 위치인 100px 을 유지하는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    delay : 3,
    duration : 2,
    fill : 'both'
});
{code}

h4. playbackRate : 재생 속도

재생속도를 지정 할 수 있으며 기본값은 1 이다. 만약 2로 지정하면 애니메이션이 2배속으로 진행되며 duration 으로 지정한 재생 시간도 그만큼 짧아진다.

h4. direction : 재생 방향

재생 방향으로, 아래 4가지 값 중 하나를 사용 할 수 있으며 기본값은 normal 이다.

* normal : 시작상태부터 종료상태까지 변화(정방향)한다.
* reverse : 종료상태에서 시작상태로 변화(역방향)한다.
* alternate : 정방향부터 시작해서 역방향과 번갈아가면서 이터레이션이 바뀔때마다 변화한다.
* alternate-reverse : 역방향부터 시작해서 정방향과 번갈아가면서 이터레이션이 바뀔때마다 변화한다.

{code}
// 0px 에서 100px 로 1초동안, 100px 에서 0px 로 1초동안, 다시 0px 에서 100px 으로 1초동안 진행되는 객체 생성
var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    duration : 1,
    iterations : 3,
    direction : 'alternate'
});
{code}

h4. easing : 재생 효과

CSS Transition 에서 지정 할 수 있는 Timing-function 문자열을 사용 할 수 있으며, 기본값은 linear 이다.

h3. SeqGroup

여러 개의 애니메이션 객체를 *순서대로* 진행 되도록 묶는 데 사용한다.

{code}
// A 애니메이션이 끝나고 B 애니메이션이 진행되게 하는 애니메이션 객체를 생성한다.
var a = new Animation(...A애니메이션...);
var b = new Animation(...B애니메이션...);
var anim = new SeqGroup([ a, b ]);
{code}

또한 두번째 인자로 TimingInput 인터페이스의 객체를 넣을 수 있어서 일련의 동작을 하나의 iteration 으로 보았을 때의 세부적인 동작을 지정 할 수 있다.

{code}
// A 애니메이션이 끝나고 B 애니메이션이 진행되는 동작을 2번 반복하는 애니메이션 객체를 생성한다.
var a = new Animation(...A애니메이션...);
var b = new Animation(...B애니메이션...);
var anim = new SeqGroup([ a, b ], {
    iterations : 2
});
{code}

h3. ParGroup

여러 개의 애니메이션 객체를 *동시에* 진행 되도록 묶는 데 사용한다.

{code}
// A 애니메이션과 B 애니메이션이 동시에 진행되게 하는 애니메이션 객체를 생성한다.
var a = new Animation(...A애니메이션...);
var b = new Animation(...B애니메이션...);
var anim = new ParGroup([ a, b ]);
{code}

또한 두번째 인자로 TimingInput 인터페이스의 객체를 넣을 수 있어서 일련의 동작을 하나의 iteration 으로 보았을 때의 세부적인 동작을 지정 할 수 있다.

{code}
// A 애니메이션과 B 애니메이션이 동시에 진행되는 동작을 2번 반복하는 애니메이션 객체를 생성한다.
var a = new Animation(...A애니메이션...);
var b = new Animation(...B애니메이션...);
var anim = new ParGroup([ a, b ], {
    iterations : 2
});
{code}

앞에서 설명 한 SeqGroup 과 조합하여 애니메이션 객체를 생성 하는 것도 가능하다.

{code}
// A 는 1초에 걸쳐서, B 는 2초에 걸쳐서 동시에 진행 되는 것이 끝나면
// B 가 3초에 걸려서 진행되는 애니메이션 객체 생성

var a = new Animation(...A애니메이션..., { duration : 1 });
var b = new Animation(...B애니메이션..., { duration : 2 });
var c = new Animation(...C애니메이션..., { duration : 3 });

var anim = new SeqGroup([
    new ParGroup([ a, b ]),
    c
]);
{code}

h3. Timeline 객체

document.timeline 을 통해 인스턴스가 존재하며, Timeline 객체가 가지고 있는 메서드 중 하나인 play 를 사용하면 생성 된 애니메이션 객체를 동작 시킬 수 있다.

{code}
var anim = new Animation(...);
document.timeline.play(anim);
{code}

h2. 이벤트

애니메이션 객체는 다음과 같은 이벤트를 발생시킨다.

* start : 애니메이션이 시작 될 때 발생
* iteration : 애니메이션이 진행 될 때 발생
* end : 애니메이션이 종료 될 때 발생
* cancel : 애니메이션이 취소 될 때 발생

h2. jindo.Keyframe 처럼 사용하기

Web Animations API 는 전체적으로 jindo.Morph 컴퍼넌트와 유사한 기능을 제공하고 있다.
하지만 위에서 설명한 옵션 중 iterationStart, iteration, fill 옵션을 사용하면, jindo.Keyframe 컴퍼넌트처럼 애니메이션이 아닌 특정 상태로 변화시키는 식의 구현이 가능하다.

{code}
// target 을 0px 부터 100px 사이의 70% 시점으로 변화시킴

var anim = new Animation(target, [ {'left':'0px'}, {'left':'100px'} ], {
    iterationStart : 0.3,
    iteration : 0,
    fill : 'both'
});
document.timeline.play(anim);
{code}

h2. jindo.Morph 와 jindo.Keyframe 과의 비교

Web Animations API 는 유연하고 다양하게 활용할 수 있는 인터페이스를 채용하여 jindo.Morph 와 jindo.Keyframe 에서 구현하고 있는 기능을 모두 포괄하여 제공하고 있다.

하지만 유연한 만큼 사용방법이 복잡해서 여러개의 엘리먼트를 관리하고 싶을 때 Web Animations API 에서는 엘리먼트의 갯수와 동작의 갯수만큼 애니메이션 객체를 생성해야 하는 번거로움이 있다.

{code}
// Morph 을 사용한 코드
var morph = new jindo.Morph();
morph.pushAnimate(3000, [
    A, {
        '@left' : jindo.Effect.linear('0px', '100px'),
        '@top' : jindo.Effect.easeOut('0px', '100px')
    },
    B, { '@color' : [ '#f00', '#00f' ] }
    C, { '@width' : [ '100px', '200px' ] }
]);
morph.pushAnimate(1000, [
    B, { '@top' : '300px' }

]);
morph.play();

// Web Animations API 을 사용한 코드
var anim = new SeqGroup([
    new ParGroup([
        new Animation(A, [ { 'left' : '0px'}, { 'left' : '100px'} ], { easing : 'linear' }),
        new Animation(A, [ { 'top' : '0px'}, { 'top' : '100px'} ], { easing : 'ease-out' }),
        new Animation(B, [ { 'color' : '#f00'}, { 'color' : '#00f'} ]),
        new Animation(C, [ { 'width' : '100px'}, { 'width' : '200px'} ])
    ], { duration : 3 }),
    new Animation(B, { 'top' : '300px'}, { duration : 1 })
]);
document.timeline.play(anim);
{code}

그러나 차후 실제 웹브라우저에서 native 로 구현 되었을 때에는 속도면에서 큰 우위를 차지 할 것이라 생각되며, 그때는 jindo.Morph, jindo.Keyframe 에서 Web Animations API 를 사용하도록 개선해야 할 것이다.